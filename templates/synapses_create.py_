{% extends 'common.py_' %}
{#
USES_VARIABLES { _synaptic_pre, _synaptic_post, _all_pre, _all_post, rand, N,
                 N_pre, N_post, _source_offset, _target_offset }
#}
{# WRITES_TO_READ_ONLY_VARIABLES { _synaptic_pre, _synaptic_post, N}
#}
# ITERATE_ALL { _idx }

######################## TEMPLATE SUPPORT CODE ##############################

{% block template_support_code %}

W = max(1000000/N_pre, 1)
_buffer_size = N_pre*W

_prebuf = _numpy.zeros(_buffer_size, dtype=_numpy.int32)
_postbuf = _numpy.zeros(_buffer_size, dtype=_numpy.int32)
_curbuf = 0

@jit
def _flush_buffer(buf, dynarr, buf_len):
    _curlen = dynarr.shape[0]
    _newlen = _curlen+buf_len
    # Resize the array
    dynarr.resize(_newlen)
    # Get the potentially newly created underlying data arrays
    data = dynarr.data
    data[_curlen:_curlen+buf_len] = buf[:buf_len]

@jit
def _synapses_create_post(_curbuf, _i, _prebuf, _postbuf, _source_offset, _target_offset, _buffer_size ,{{subroutine_parameters}}):
    for _j in range(_num{{_all_post}}):
        _vectorisation_idx = _j

        {# The abstract code consists of the following lines (the first two lines
        are there to properly support subgroups as sources/targets):
        _pre_idx = _all_pre
        _post_idx = _all_post
        _cond = {user-specified condition}
        _n = {user-specified number of synapses}
        _p = {user-specified probability}
        #}
        
        # vector code
        {{vector_code|autoindent}}
        
        # add to buffer
        if _cond:
            if _p!=1.0:
                if _rand(_vectorisation_idx)>=_p:
                    continue
            for _repetition in range(_n):
                _prebuf[_curbuf] = _pre_idx
                _postbuf[_curbuf] = _post_idx
                _curbuf += 1
                # Flush buffer
                if _curbuf==_buffer_size:
                    _flush_buffer(_prebuf, {{_dynamic__synaptic_pre}}, _curbuf)
                    _flush_buffer(_postbuf, {{_dynamic__synaptic_post}}, _curbuf)
                    _curbuf = 0

    return {{subroutine_parameters}}

@jit
def _synapses_create_pre(_i0, _curbuf, W, _prebuf, _postbuf, _source_offset, _target_offset, _buffer_size, {{subroutine_parameters}}):
    for _i in range(_i0, min(_i0+W-1, _num{{_all_pre}})):
        {{subroutine_parameters}} = _synapses_create_post(_curbuf, _i, _prebuf, _postbuf, _source_offset, _target_offset, _buffer_size, {{subroutine_arguments}})

    return {{subroutine_parameters}}
    
{% endblock %}

######################## MAIN CODE ##############################

{% block maincode %}

    global _curbuf

    oldsize = len({{_dynamic__synaptic_pre}})    
    
    # scalar code
    _vectorisation_idx = 1
    {{scalar_code|autoindent}}

    for _i0 in range(0, _num{{_all_pre}}, W):
        {{subroutine_parameters}} = _synapses_create_pre(_i0, _curbuf, W, _prebuf, _postbuf, _source_offset, _target_offset, _buffer_size, {{subroutine_arguments}})
                    
    # Final buffer flush
    _flush_buffer(_prebuf, {{_dynamic__synaptic_pre}}, _curbuf)
    _flush_buffer(_postbuf, {{_dynamic__synaptic_post}}, _curbuf)
    _curbuf = 0  # reset the buffer for the next run

    newsize = len({{_dynamic__synaptic_pre}})
    # now we need to resize all registered variables and set the total number
    # of synapse (via Python)
    _owner._resize(newsize)

    # And update N_incoming, N_outgoing and synapse_number
    _owner._update_synapse_numbers(oldsize)

{% endblock %}
