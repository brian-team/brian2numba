{% extends 'common.py_' %}

{% block template_support_code %}

@jit(nopython=True)
def _ratemonitor(_spikespace, _num_spikespace, _source_start, _source_stop):
    _num_spikes = _spikespace[_num_spikespace-1]
    
    # For subgroups, we do not want to record all spikes
    # We assume that spikes are ordered
    _start_idx = 0
    _end_idx = -1
    
    for _j in range(_num_spikes):
        _idx = _spikespace[_j]
        if _idx >= _source_start:
            _start_idx = _j
            break
    for _j in range(_start_idx, _num_spikes):
        _idx = _spikespace[_j]
        if _idx >= _source_stop:
            _end_idx = _j
            break
    if _end_idx == -1:
        _end_idx =_num_spikes
    _num_spikes = _end_idx - _start_idx

    return _num_spikes, _spikespace, _num_spikespace

{% endblock %}

{% block maincode %}
    {# USES_VARIABLES { t, rate, _clock_t, _clock_dt, _spikespace,
                        _num_source_neurons, _source_start, _source_stop } #}
    
    _num_spikes, _spikespace, _num_spikespace = _ratemonitor({{_spikespace}}, _num{{_spikespace}}, _source_start, _source_stop)

    # Calculate the new length for the arrays
    _new_len = {{_dynamic_t}}.shape[0] + 1

    # Resize the arrays
    _owner.resize(_new_len)

    # Set the new values
    {{_dynamic_t}}.data[_new_len-1] = {{_clock_t}}
    {{_dynamic_rate}}.data[_new_len-1] = _num_spikes/{{_clock_dt}}/_num_source_neurons

{% endblock %}
